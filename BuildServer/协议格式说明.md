# 网络消息包协议格式说明

## 📦 消息包结构

完整的消息包由两部分组成：

```
[消息包头] + [消息包体]
```

---

## 1️⃣ 消息包头 (PacketHeader)

### 结构定义

```csharp
CSPacketHeader / SCPacketHeader
{
    Id: int          // 消息包ID（ProtoBuf字段1）
    PacketLength: int // 消息包体总长度（ProtoBuf字段2）
}
```

### 序列化格式

使用 **ProtoBuf** 序列化，格式为：
- `Id` 字段：ProtoBuf字段1，Varint编码
- `PacketLength` 字段：ProtoBuf字段2，Varint编码

### 示例（心跳包）

**客户端发送心跳包：**
- `Id = 1` → ProtoBuf编码：`08-01`（字段1，值1）
- `PacketLength = 4` → ProtoBuf编码：`10-04`（字段2，值4）
- **消息包头总长度：4字节** (`08-01-10-04`)

**服务器发送心跳响应：**
- `Id = 2` → ProtoBuf编码：`08-02`（字段1，值2）
- `PacketLength = 4` → ProtoBuf编码：`10-04`（字段2，值4）
- **消息包头总长度：4字节** (`08-02-10-04`)

---

## 2️⃣ 消息包体 (PacketBody)

### 结构定义

消息包体由两部分组成：

```
[Fixed32长度前缀（4字节）] + [实际消息包体（ProtoBuf序列化）]
```

### 详细说明

1. **Fixed32长度前缀**（4字节，小端序）
   - 表示**实际消息包体**的长度（不包括长度前缀本身）
   - 使用 `Serializer.SerializeWithLengthPrefix(..., PrefixStyle.Fixed32)` 自动添加

2. **实际消息包体**（ProtoBuf序列化）
   - 消息包的具体数据（如 `CSHeartBeat`、`SCHeartBeat` 等）
   - 使用 ProtoBuf 序列化

### 示例（心跳包）

**客户端心跳包 (`CSHeartBeat`，空类)：**
- Fixed32长度前缀：`00-00-00-00`（4字节，表示实际包体长度为0）
- 实际消息包体：空（0字节）
- **消息包体总长度：4字节** (`00-00-00-00`)

**服务器心跳响应 (`SCHeartBeat`，空类)：**
- Fixed32长度前缀：`00-00-00-00`（4字节，表示实际包体长度为0）
- 实际消息包体：空（0字节）
- **消息包体总长度：4字节** (`00-00-00-00`)

---

## 📊 完整消息包示例（心跳包）

### 客户端 → 服务器（CSHeartBeat）

```
完整消息包（8字节）：
┌─────────────────────────────────────────┐
│ 消息包头（4字节）                        │
├─────────────────────────────────────────┤
│ 08-01  │ Id=1 (字段1, 值1)              │
│ 10-04  │ PacketLength=4 (字段2, 值4)    │
├─────────────────────────────────────────┤
│ 消息包体（4字节）                        │
├─────────────────────────────────────────┤
│ 00-00-00-00 │ Fixed32长度前缀（0字节）   │
│             │ 实际包体：空（0字节）       │
└─────────────────────────────────────────┘
```

**十六进制数据：** `08-01-10-04-00-00-00-00`

### 服务器 → 客户端（SCHeartBeat）

```
完整消息包（8字节）：
┌─────────────────────────────────────────┐
│ 消息包头（4字节）                        │
├─────────────────────────────────────────┤
│ 08-02  │ Id=2 (字段1, 值2)              │
│ 10-04  │ PacketLength=4 (字段2, 值4)    │
├─────────────────────────────────────────┤
│ 消息包体（4字节）                        │
├─────────────────────────────────────────┤
│ 00-00-00-00 │ Fixed32长度前缀（0字节）   │
│             │ 实际包体：空（0字节）       │
└─────────────────────────────────────────┘
```

**十六进制数据：** `08-02-10-04-00-00-00-00`

---

## 🔢 长度计算详解

### 客户端发送时（NetworkChannelHelper.Serialize）

```csharp
// 步骤1：序列化消息包体（带Fixed32长度前缀）
Serializer.SerializeWithLengthPrefix(bodyStream, packet, PrefixStyle.Fixed32);
// bodyStream 现在包含：
//   - 4字节 Fixed32长度前缀（表示实际包体长度）
//   - N字节 实际消息包体（ProtoBuf序列化）

// 步骤2：计算消息包体总长度
int packetBodyLength = (int)bodyStream.Length;
// packetBodyLength = 4 + N（N是实际包体的字节数）

// 步骤3：设置消息包头
packetHeader.Id = packetImpl.Id;
packetHeader.PacketLength = packetBodyLength;  // 设置为总长度

// 步骤4：序列化消息包头
Serializer.Serialize(headerStream, packetHeader);
// headerStream 包含消息包头（ProtoBuf序列化，通常是4字节）

// 步骤5：组合完整消息包
// 最终数据 = 消息包头 + 消息包体
// 总长度 = headerStream.Length + bodyStream.Length
```

### 服务器接收时（ClientConnection.HandleClientAsync）

```csharp
// 步骤1：反序列化消息包头
CSPacketHeader packetHeader = DeserializePacketHeaderAsync();
// packetHeader.Id = 1
// packetHeader.PacketLength = 4（这是消息包体的总长度）

// 步骤2：读取Fixed32长度前缀（4字节）
byte[] lengthBuffer = new byte[4];
ReadBytesAsync(lengthBuffer, 0, 4);
// lengthBuffer = [00-00-00-00]

// 步骤3：解析长度前缀
int packetBodyLength = BitConverter.ToInt32(lengthBuffer, 0);
// packetBodyLength = 0（这是实际包体的长度，不包括长度前缀）

// 步骤4：读取实际消息包体
if (packetBodyLength > 0) {
    ReadBytesAsync(packetBodyBuffer, 0, packetBodyLength);
}
// 对于心跳包，packetBodyLength=0，所以不读取
```

---

## 📐 长度计算公式

### 消息包体总长度（PacketLength）

```
PacketLength = 4字节（Fixed32长度前缀） + 实际包体长度（N字节）
```

**示例：**
- 心跳包（空类）：`PacketLength = 4 + 0 = 4字节`
- 如果有数据的包（假设实际包体10字节）：`PacketLength = 4 + 10 = 14字节`

### 完整消息包总长度

```
完整消息包长度 = 消息包头长度 + PacketLength
```

**示例（心跳包）：**
- 消息包头：4字节（`08-01-10-04`）
- PacketLength：4字节
- **完整消息包：4 + 4 = 8字节**

---

## 🔍 ProtoBuf字段编码说明

### Varint编码

ProtoBuf使用Varint编码来压缩整数：
- 字段号左移3位 + WireType（低3位）
- 值使用Varint编码（可变长度）

**示例：**
- `Id=1`：字段1，WireType=0（Varint）
  - 字段标记：`(1 << 3) | 0 = 0x08`
  - 值：`0x01`
  - 编码：`08-01`（2字节）

- `PacketLength=4`：字段2，WireType=0（Varint）
  - 字段标记：`(2 << 3) | 0 = 0x10`
  - 值：`0x04`
  - 编码：`10-04`（2字节）

### Fixed32编码

Fixed32长度前缀使用固定4字节，小端序：
- 值0：`00-00-00-00`
- 值4：`04-00-00-00`
- 值10：`0A-00-00-00`

---

## ⚠️ 重要注意事项

1. **PacketLength的含义**
   - 在消息包头中：`PacketLength` = 4字节（长度前缀）+ 实际包体长度
   - 在Fixed32长度前缀中：值 = 实际包体长度（不包括长度前缀）

2. **Id属性**
   - `Id` 属性不应该在消息包体中序列化
   - 使用 `[ProtoIgnore]` 标记，确保只在消息包头中

3. **空消息包**
   - 如果消息包体为空（如心跳包），Fixed32长度前缀为 `00-00-00-00`
   - 但 `PacketLength` 仍然是 `4`（因为包括长度前缀本身）

4. **字节序**
   - Fixed32长度前缀使用**小端序**（Little-Endian）
   - 使用 `BitConverter.ToInt32()` 解析时，会自动处理字节序

---

## 📝 总结

| 组成部分 | 长度 | 说明 |
|---------|------|------|
| 消息包头 | 4字节（通常） | ProtoBuf序列化的 `CSPacketHeader`/`SCPacketHeader` |
| Fixed32长度前缀 | 4字节 | 固定4字节，小端序，表示实际包体长度 |
| 实际消息包体 | N字节 | ProtoBuf序列化的消息包数据 |
| **消息包体总长度** | **4 + N字节** | **PacketLength = 4 + N** |
| **完整消息包** | **4 + (4 + N)字节** | **总长度 = 消息包头 + PacketLength** |

**心跳包示例：**
- 消息包头：4字节
- PacketLength：4字节（4 + 0）
- 完整消息包：8字节

